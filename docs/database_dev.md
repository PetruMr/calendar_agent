# Progettazione database

Dato il nostro diagramma E/R, andiamo a definire le tabelle del database PostgreSQL che andremo ad utilizzare per la nostra applicazione di scheduling delle chiamate HR.

## Tabelle del database

### 1. `users`

Questa tabella conterrà le informazioni degli utenti che possono essere reclutatori o partecipanti alle chiamate.

```sql
create table public.users (
  id bigint generated by default as identity not null,
  nome text not null,
  email text not null,
  password text null,
  salt text not null,
  tipo text null,
  username text null,
  constraint users_pkey primary key (id),
  constraint users_email_key unique (email)
) TABLESPACE pg_default;
```

Vi sarà poi la tabella `user_oauth_tokens` per gestire i token OAuth degli utenti:

```sql
create table if not exists public.user_oauth_tokens (
  id bigserial primary key,
  user_id bigint not null, 
  provider text not null,
  access_token text,
  refresh_token text,
  scope text,
  token_type text,
  expiry_date bigint,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique (user_id, provider)
);

-- Questi trigger sono placeholder, da capire se ha senso usarli o magari è meglio ometterli e gestire l'aggiornamento di `updated_at` a livello applicativo

-- updated_at trigger in modo da aggiornare il campo ad ogni modifica
create or replace function public.set_updated_at() 
returns trigger language plpgsql as $$
begin 
  new.updated_at = now(); 
  return new; 
end; $$;

drop trigger if exists trg_user_oauth_tokens_updated on public.user_oauth_tokens;

-- Creiamo il trigger che aggiorna updated_at ad ogni modifica
create trigger trg_user_oauth_tokens_updated
before update on public.user_oauth_tokens
for each row
execute function public.set_updated_at();

-- Abilitiamo la Row Level Security per questa tabella e impostiamo una policy di default che nega l'accesso a tutti gli utenti
alter table public.user_oauth_tokens enable row level security;
create policy "deny all" on public.user_oauth_tokens for all using (false);
```

### 2. `calls`

Questa tabella conterrà le informazioni sulle chiamate organizzate.

```sql
create table public.calls (
  id bigint generated by default as identity not null,
  data_creazione timestamp with time zone not null default now(),
  data_call timestamp without time zone null,
  data_deadline timestamp without time zone null,
  stato_avanzamento text null,
  tipo text null,
  durata bigint null,
  note text null,
  link_meet text null,
  constraint calls_pkey primary key (id)
) TABLESPACE pg_default;
```

### 3. `users_calls`

Questa tabella rappresenta la relazione tra gli utenti e le chiamate, permettendo di associare più utenti a più chiamate.

```sql
create table public.users_calls (
  call_id bigint not null,
  user_id bigint not null,
  calendario boolean not null default false,
  stato text null,
  token text null,
  created_at timestamp with time zone null default now(),
  lastmail_sent_at timestamp with time zone null,
  mails_sent bigint null default '0'::bigint,
  constraint participants_pkey primary key (call_id, user_id),
  constraint participants_call_id_fkey foreign KEY (call_id) references calls (id) on update CASCADE on delete CASCADE,
  constraint participants_user_id_fkey foreign KEY (user_id) references users (id) on update CASCADE on delete CASCADE
) TABLESPACE pg_default;
```

Definisce diversi dati utili che servono in particolar modo a chi non ha collegato il proprio account a Google Calendar: